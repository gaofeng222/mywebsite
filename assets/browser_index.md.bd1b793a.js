import{_ as e,c as r,o as a,a as t}from"./app.e6464ad1.js";const b=JSON.parse('{"title":"Dom相关知识点","description":"","frontmatter":{"title":"Dom相关知识点","editLink":true},"headers":[],"relativePath":"browser/index.md","lastUpdated":1677403524000}'),i={name:"browser/index.md"},n=t('<h1 id="dom-渲染的原理" tabindex="-1">Dom 渲染的原理 <a class="header-anchor" href="#dom-渲染的原理" aria-hidden="true">#</a></h1><p><a href="https://imgse.com/i/pSjOHVH" target="_blank" rel="noreferrer"><img src="https://s1.ax1x.com/2023/02/22/pSjOHVH.png" alt="pSjOHVH.png"></a></p><h2 id="_1-浏览器渲染的顺序" tabindex="-1">1.浏览器渲染的顺序： <a class="header-anchor" href="#_1-浏览器渲染的顺序" aria-hidden="true">#</a></h2><p>1.解析 html 构建 dom 树 =&gt;2.解析 css 构建 css 树 =&gt;3.合并 dom 和 css 规则，构建渲染 render 树 =&gt;4.节点布局 =&gt;5.页面渲染 =&gt; 6.展示眼前</p><ul><li>解析 HTML，构建 DOM 树（这里遇到外链，此时会发起请求）</li><li>解析 CSS，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算</li><li>绘制 render 树（paint），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 将各层合成（composite），显示在屏幕上</li></ul><blockquote><p>页面得渲染流程总得俩说就五步，创建 DOM 树——创建 StyleRules——创建 Render 树——布局 Layout（重排）——绘制 Painting（重绘）</p></blockquote><blockquote><p>第一步，用 HTML 分析器，分析 HTML 元素，构建一颗 DOM 树(标记化和树构建)。</p></blockquote><blockquote><p>第二步，用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表。</p></blockquote><blockquote><p>第三步，将 DOM 树和样式表，关联起来，构建一颗 Render 树(这一过程又称为 Attachment)。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象(又名 renderer)。这些 render 对象最终会被构建成一颗 Render 树。</p></blockquote><blockquote><p>第四步，有了 Render 树，浏览器开始布局，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标。</p></blockquote><blockquote><p>第五步，Render 树和节点显示坐标都有了，就调用每个节点 paint 方法，把它们绘制出来</p></blockquote><h2 id="_2-什么是-dom-树" tabindex="-1">2.什么是 dom 树？ <a class="header-anchor" href="#_2-什么是-dom-树" aria-hidden="true">#</a></h2><ul><li>浏览器将 HTML 解析成树形的数据结构，简称 DOM。 DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 解析树的根节点是 Document 对象。</li></ul><h2 id="_3-什么是-css-树" tabindex="-1">3.什么是 css 树？ <a class="header-anchor" href="#_3-什么是-css-树" aria-hidden="true">#</a></h2><h2 id="_4-什么是渲染树-render-树" tabindex="-1">4.什么是渲染树(render 树)？ <a class="header-anchor" href="#_4-什么是渲染树-render-树" aria-hidden="true">#</a></h2><ul><li>浏览器在构造 DOM 树的同时也在构造着另一棵树-Render Tree,与 DOM 树相对应暂且叫它 Render 树。我们知道 DOM 树为 javascript 提供了一些列的访问接口（DOM API），但这棵树是不对外的。它的主要作用就是把 HTML 按照一定的布局与样式显示出来，用到了 CSS 的相关知识。从 MVC 的角度来说，可以将 render 树看成是 V，dom 树看成是 M，C 则是具体的调度者，比 HTMLDocumentParser 等。</li></ul><h2 id="_5-深入浅出浏览器渲染原理" tabindex="-1">5.深入浅出浏览器渲染原理 <a class="header-anchor" href="#_5-深入浅出浏览器渲染原理" aria-hidden="true">#</a></h2><p><a href="https://imgse.com/i/pSjzC60" target="_blank" rel="noreferrer"><img src="https://s1.ax1x.com/2023/02/22/pSjzC60.png" alt="pSjzC60.png"></a></p><h2 id="_6-何时触发-reflow-和-repaint" tabindex="-1">6.何时触发 reflow 和 repaint <a class="header-anchor" href="#_6-何时触发-reflow-和-repaint" aria-hidden="true">#</a></h2><ul><li>reflow(回流): 根据 Render Tree 布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；</li><li>repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了； reflow 回流的成本开销要高于 repaint 重绘，一个节点的回流往往回导致子节点以及同级节点的回流</li></ul><blockquote><p>重绘不会导致回流,回流则一定会引起重绘</p></blockquote><h2 id="_7-如何减少回流和重绘" tabindex="-1">7.如何减少回流和重绘？ <a class="header-anchor" href="#_7-如何减少回流和重绘" aria-hidden="true">#</a></h2><p>1.使用 transform 替代 top<br> 2.使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）<br> 3.不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局<br> 4.动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame<br> 5.CSS 选择符从右往左匹配查找，避免节点层级过多<br> 6.将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。</p><p>参考链接: <a href="https://blog.csdn.net/egegerhn/article/details/123121149/" target="_blank" rel="noreferrer">浏览器的渲染原理</a></p>',24),o=[n];function d(l,s,c,h,p,_){return a(),r("div",null,o)}const m=e(i,[["render",d]]);export{b as __pageData,m as default};
