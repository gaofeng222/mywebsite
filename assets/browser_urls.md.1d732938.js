import{_ as p,c as e,o as r,a}from"./app.e6464ad1.js";const _=JSON.parse('{"title":"浏览器输入 url 到页面展示出来的全过程","description":"","frontmatter":{},"headers":[],"relativePath":"browser/urls.md","lastUpdated":1677403524000}'),l={name:"browser/urls.md"},i=a('<h1 id="浏览器输入-url-到页面展示出来的全过程" tabindex="-1">浏览器输入 url 到页面展示出来的全过程 <a class="header-anchor" href="#浏览器输入-url-到页面展示出来的全过程" aria-hidden="true">#</a></h1><p><a href="https://imgse.com/i/pSvTNF0" target="_blank" rel="noreferrer"><img src="https://s1.ax1x.com/2023/02/23/pSvTNF0.md.png#pic_center" alt="pSvTNF0.md.png"></a></p><h2 id="基本流程" tabindex="-1">基本流程： <a class="header-anchor" href="#基本流程" aria-hidden="true">#</a></h2><p>1、用户在浏览器中输入 url 地址</p><p>2、浏览器解析域名得到服务器 ip 地址</p><p>浏览器会首先从缓存中找是否存在域名，如果存在就直接取出对应的 ip 地址，如果没有就开启一个 DNS 域名解析器。DNS 域名解析器会首先访问顶级域名服务器，将对应的 ip 发给客户端；然后访问根域名解析器，将对应的 ip 发给客户端；最后访问本地域名服务器，得到最终的 ip 地址。</p><p>3、TCP 三次握手建立客户端和服务器的连接</p><p>因为 HTTP 是基于 TCP 的可靠传输，所以在发送 http 数据报之前，需要先进行 TCP 的三次握手建立连接。三次握手过程如下：</p><p>第一次握手：客户端---&gt;服务端 ack=1,seq=x（x 随机生成）</p><p>第二次握手：服务端---&gt;客户端 ACK=1,ack=x+1,seq=y（y 随机生成）</p><p>第三次握手：客户端---&gt;服务端 ACK=1,ack=y+1,seq=x+1</p><p>完成第三次握手时，实际上客户端已经与服务器建立了连接，所以第三次握手的报文已经可以携带数据了。</p><p>4、客户端发送 HTTP 请求获取服务器端的静态资源</p><p>5、服务器发送 HTTP 响应报文给客户端，客户端获取到页面静态资源</p><p>6、TCP 四次挥手关闭客户端和服务器的连接</p><p><a href="https://imgse.com/i/pSvTomd" target="_blank" rel="noreferrer"><img src="https://s1.ax1x.com/2023/02/23/pSvTomd.png" alt="pSvTomd.png"></a></p><p>数据传输完毕后，TCP 会进行四次挥手断开连接，释放资源。四次挥手过程如下：</p><p>第一次挥手：客户端---&gt;服务器 FIN=1,ack=1,seq=u 客户端状态变为 FIN_WAIT_1</p><p>第二次挥手：服务器---&gt;客户端 ACK=1,ack=u+1,seq=v 服务器状态变为 CLOSE_WAIT，TCP 进入半关闭状态</p><p>第三次挥手：服务器---&gt;客户端 FIN=1,ACK=1,ack=u+1,seq=w 服务器状态变为 LAST_ACK</p><p>第四次挥手：客户端---&gt;服务器 ACK=1,ack=w+1,seq=u+1 客户端状态变为 TIME_WAIT，此时 TCP 未释放，需要等待计时器计时完成后，客户端状态变为 CLOSED</p><p><a href="https://imgse.com/i/pSvTDOJ" target="_blank" rel="noreferrer"><img src="https://s1.ax1x.com/2023/02/23/pSvTDOJ.md.png" alt="pSvTDOJ.md.png"></a></p><p>7、浏览器解析文档资源并渲染页面</p><p>浏览器解析文档资源并渲染页面流程：</p><p>（1）解析 html 资源，构建 DOM Tree</p><p>（2）解析 css 资源，构建 CSS Rule Tree</p><p>（3）JS 通过 DOM API 和 CSS OM API 来操作 DOM Tree 和 CSS Tree</p><p>（4）解析完成后综合 DOM Tree 和 CSS Tree 会生成 Render Tree，计算每个元素的位置，这个过程就是回流（layout or reflow）</p><p>（5）调用操作系统 Native GUI 的绘制</p><p>（6）页面绘制完成</p><h2 id="涉及到的其他知识点" tabindex="-1">涉及到的其他知识点： <a class="header-anchor" href="#涉及到的其他知识点" aria-hidden="true">#</a></h2><p>1、Render Tree 的生成</p><p>DOM Tree 和 CSS Tree 结合会生成 Render Tree，是由可视化元素按照其顺序生成的树形结构，非可视化元素是不会出现到渲染树中的。</p><p>非可视化元素：head、display：none；（注意：visibility：hidden 的元素会出现在渲染树中）</p><p>2、回流和重绘</p><p>回流（reflow，也叫重排、布局）：某部分的变化影响了布局，浏览器需要重新渲染。（如元素大小、位置的改变）</p><p>重绘（repaint）：元素的某一部分发生改变，尺寸、位置没有改变。（字体颜色、背景颜色的改变）</p><p>引起回流的几个主要原因：</p><p>（1）网页初始化</p><p>（2）JS 操作 DOM 树（增加、删除元素等）</p><p>（3）某些元素的尺寸改变</p><p>（4）CSS 属性的改变</p><p>浏览器的<code>dirty</code>系统：</p><p>为了避免页面细小的改变就引起回流和重绘，<code>dirty</code>系统会将这些改变操作积攒一批再进行操作，这又叫异步 reflow 或者增量异步 reflow。有些特殊情况不会这么做：resize 窗口、改变了页面默认的字体等，这些操作会直接触发回流。</p><p>编写代码时如何减少回流和重绘：</p><p>（1）修改样式不要逐条修改，定义 CSS 样式的 class，直接修改元素的 className</p><p>（2）不要将 DOM 节点的属性值放在循环中当成循环的变量</p><p>（3）为动画的 HTML 元素使用 fixed 或 absolute 的 position 属性，修改它们的 CSS 就不会触发 reflow</p><p>（4）把 DOM 离线后修改，设置 display：none 或者 clone 元素到内存中，修改完成再显示回页面</p><p>（5）不要使用 table 布局，一个微小的改变就可能引起整个 table 的重新布局</p><p>3、性能优化</p><p>（1）提升 HTML 的加载速度</p><ul><li><p>页面精简，删除不必要的内容，将内嵌的 JS 和 CSS 移至外部文件，使用压缩工具等</p></li><li><p>减少文件数量，合并文件，减少请求次数</p></li><li><p>减少域名查询，外部引入的资源尽量少使用不同的域名</p></li><li><p>使用缓存，重用数据</p></li><li><p>优化页面元素的加载顺序</p></li><li><p>使用合法的标签</p></li><li><p>根据浏览器类型选择合适的策略</p></li></ul><p>（2）编写合理的 CSS</p><ul><li><p>DOM 的深度尽量浅</p></li><li><p>使用合法的 CSS 属性</p></li><li><p>不要为 ID 选择器指定类名或标签名</p></li><li><p>避免使用后代选择器，尽量使用子选择器</p></li><li><p>避免使用通配符</p></li></ul><p>（3）关于 JS 标签</p><p>js 标签的加载和执行特点：载入后立即执行，执行时会阻塞页面后续内容</p><ul><li><p>将所有的 js 标签放在页面底部，保证脚本执行前已完成 DOM 渲染</p></li><li><p>尽可能合并脚本</p></li><li><p>减少内联 js 的使用</p></li><li><p>注意多个 js 标签的引入顺序</p></li><li><p>使用 defer 属性，该属性可以使脚本在文档完全呈现以后再执行</p></li><li><p>使用 async 属性，可以使当前脚本不必等待其他脚本的执行，也不必阻塞文档的呈现</p></li></ul><p>参考链接 1： <a href="https://blog.csdn.net/cute_ming/article/details/124364783" target="_blank" rel="noreferrer">浏览器输入 url 到页面展示出来的全过程 </a></p><p>参考链接 2：<a href="https://www.sohu.com/a/320368499_262549" target="_blank" rel="noreferrer">一个 TCP 连接能发多少个 HTTP 请求，万万没想到</a></p>',60),t=[i];function s(o,n,c,d,T,S){return r(),e("div",null,t)}const u=p(l,[["render",s]]);export{_ as __pageData,u as default};
