import{_ as n,c as l,o as p,a,b as s}from"./app.e6464ad1.js";const o="/mywebsite/assets/xss.98550ad6.png",g=JSON.parse('{"title":"XSS 攻击","description":"","frontmatter":{},"headers":[],"relativePath":"webSafe/xss.md","lastUpdated":1678935368000}'),e={name:"webSafe/xss.md"},t=o+"#pic_center",c=a('<h1 id="xss-攻击" tabindex="-1">XSS 攻击 <a class="header-anchor" href="#xss-攻击" aria-hidden="true">#</a></h1><p><strong>XSS</strong>（cross-site scripting <strong>跨域脚本攻击</strong>）攻击是最常见的 Web 攻击，其重点是<strong>跨域</strong>和<strong>客户端执行</strong>。有人将 XSS 攻击分为三种，分别是：</p><ol><li><p><code>Reflected XSS</code>（基于反射的 XSS 攻击）</p></li><li><p><code>Stored XSS</code>（基于存储的 XSS 攻击）</p></li><li><p><code>DOM-based</code> or <code>local XSS</code>（基于 DOM 或本地的 XSS 攻击）</p></li></ol><h2 id="dom-based-or-local-xss" tabindex="-1">DOM-based or local XSS <a class="header-anchor" href="#dom-based-or-local-xss" aria-hidden="true">#</a></h2><p>基于 DOM 或本地的 XSS 攻击。一般是提供一个免费的 wifi，但是提供免费 wifi 的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的 XSS 攻击。</p><p>比如：</p><ol><li><p>提供一个免费的 wifi。</p></li><li><p>开启一个特殊的 DNS 服务，将所有域名都解析到我们的电脑上，并把 Wifi 的 DHCP-DNS 设置为我们的电脑 IP。</p></li><li><p>之后连上 wifi 的用户打开任何网站，请求都将被我们截取到。我们根据 http 头中的 host 字段来转发到真正服务器上。</p></li><li><p>收到服务器返回的数据之后，我们就可以实现网页脚本的注入，并返回给用户。</p></li><li><p>当注入的脚本被执行，用户的浏览器将依次预加载各大网站的常用脚本库。</p></li></ol><p><strong>这个其实就是 wifi 流量劫持，中间人可以看到用户的每一个请求，可以在页面嵌入恶意代码，使用恶意代码获取用户的信息，可以返回钓鱼页面。</strong></p><p>再比如：</p><ol><li><p>还是提供一个免费 wifi</p></li><li><p>在我们电脑上进行抓包</p></li><li><p>分析数据，可以获取用户的微信朋友圈、邮箱、社交网站帐号数据（HTTP）等。</p></li></ol>',10),r=s("p",null,[s("img",{src:t,alt:"示例图片"})],-1),i=a(`<p>结论：</p><p>这攻击其实跟网站本身没有什么关系，只是数据被中间人获取了而已，而由于 HTTP 是明文传输的，所以是极可能被窃取的。</p><h2 id="开发安全措施" tabindex="-1">开发安全措施： <a class="header-anchor" href="#开发安全措施" aria-hidden="true">#</a></h2><ol><li>使用 HTTPS！就跟我前面<a href="http://www.cnblogs.com/lovesong/p/5186200.html" target="_blank" rel="noreferrer">《HTTP 与 HTTPS 握手的那些事》</a>这篇文章说的，HTTPS 会在请求数据之前进行一次握手，使得客户端与服务端都有一个私钥，服务端用这个私钥加密，客户端用这个私钥解密，这样即使数据被人截取了，也是加密后的数据。</li></ol><p>服务端可以干的事:</p><ol start="2"><li>HttpOnly</li></ol><p>其实就是现在 HTTP 协议（HTTPS 也是可以的）才能读取 cookies，JavaScript 是读取不到 cookies 的。支持浏览器是 IE6+、Firefox2+、Google、Safari4+。</p><p>JavaEE 给 Cookie 添加 HttpOnly 的代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">response</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">setHeader</span><span style="color:#A6ACCD;">(</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Set-Cookie</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">cookiename=value; Path=/;Domain=domainvalue;Max-Age=seconds;HTTPOnly</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>PS：对于 HTTPS，还是可以设置 Secure 字段，对 Cookie 进行安全加密。</p><p>这是本质上不是预防 XSS，而是在被攻破时候不允许 JS 读取 Cookie。</p><p>3.处理富文本</p><p>有些数据因为使用场景问题，并不能直接在服务端进行转义存储。不过富文本数据语义是完整的 HTML 代码，在输出时也不会拼凑到某个标签的属性中，所以可以当特殊情况特殊处理。处理的过程是在服务端配置富文本标签和属性的白名单，不允许出现其他标签或属性（例如 script、iframe、form 等），即”XSS Filter“。然后在存储之前进行过滤（过滤原理没有去探明）。</p><p>Java 有个开源项目 Anti-Samy 是非常好的 XSS Filter：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Policy ploicy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Policy</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getInstance</span><span style="color:#A6ACCD;">(POLICY_FILE_LOCATION)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">AntiSamy </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> = </span><span style="color:#FFCB6B;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AntiSamy</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">CleanResults cr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> as</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">scan</span><span style="color:#A6ACCD;">(dirtyInput</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> policy)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">MyUserDao</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">storeUserProfile</span><span style="color:#A6ACCD;">(cr</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getCleanHTML</span><span style="color:#A6ACCD;">())</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><p>PS：当然也可以在前端显示前过滤，但是我觉得，让前端人员少做东西好，并且服务端只需要转一次。</p><p>客户端可以干的事</p><ol><li>输入检查</li></ol><p>输入检查的逻辑，必须放在服务器端代码中实现（因为用 JavaScript 做输入检查，很容易被攻击者绕过）。目前 Web 开发的普遍做法，是同时在客户端 JavaScript 中和服务器代码中实现相同的输入检查。客户端 JavaScript 的输入检查，可以阻挡大部分误操作的正常用户，从而节约服务资源。</p><p>另外攻击者可能输入 XSS 的地方，例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">页面中所有的input框</span></span>
<span class="line"><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">location（href、hash等）</span></span>
<span class="line"><span style="color:#A6ACCD;">3</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name</span></span>
<span class="line"><span style="color:#A6ACCD;">4</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">referrer</span></span>
<span class="line"><span style="color:#A6ACCD;">5</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">cookie</span></span>
<span class="line"><span style="color:#A6ACCD;">6</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">localstorage</span></span>
<span class="line"><span style="color:#A6ACCD;">7</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">XMLHttpRequest返回的数据</span></span>
<span class="line"></span></code></pre></div><ol start="2"><li>输出检查</li></ol><p>一般就是在变量输出到 HTML 页面时，使用编码或转义的方式来防御 XSS 攻击。XSS 的本质就是“HTML 注入”，用户的数据被当成了 HTML 代码一部分来执行，从而混淆了原本的语义，产生了新的语义。</p><p>触发 XSS 的地方</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">write</span></span>
<span class="line"><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">xxx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">3</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">xxx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">outerHTML</span><span style="color:#89DDFF;">=</span></span>
<span class="line"><span style="color:#A6ACCD;">4</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">innerHTML</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">replace</span></span>
<span class="line"><span style="color:#A6ACCD;">5</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">attachEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">6</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">attachEvent</span></span>
<span class="line"><span style="color:#A6ACCD;">7</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">location</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">replace</span></span>
<span class="line"><span style="color:#A6ACCD;">8</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">location</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">assign</span></span>
<span class="line"></span></code></pre></div><ol start="3"><li>转义所有可能存在 xss 攻击的输入和输出</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>XSS 攻击的特点就是：尽一切办法在目标网站上执行非目标网站上原有的脚本（某篇文章说的）。本地的 XSS 攻击的示例 2 其实不算 XSS 攻击，只是简单流量劫持。前两种 XSS 攻击是我们开发时候要注意的，而流量劫持的则可以使用 HTTPS 提高安全性，。</p><p>这攻击其实跟网站本身没有什么关系，只是数据被中间人获取了而已，而由于 HTTP 是明文传输的，所以是极可能被窃取的。</p><p>一般存储型 XSS 风险高于反射型 XSS。反射型 XSS 一般要求攻击者诱使用户点击一个包含 XSS 代码的 URL 链接；而存储型只需要用户查看一个正常的 URL 链接，当用户打开页面时，XSS Payload 就会被执行。这样漏洞极其隐蔽，且埋伏在用户的正常业务中，风险很高。（引自白帽子讲 Web 安全原文）</p><p><a href="https://www.cnblogs.com/lovesong/p/5199623.html" target="_blank" rel="noreferrer">完整参考链接 1</a><a href="https://www.cnblogs.com/lovesong/p/5223989.html" target="_blank" rel="noreferrer">完整参考链接 2</a></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div>`,32),D=[c,r,i];function C(A,y,F,d,S,h){return p(),l("div",null,D)}const T=n(e,[["render",C]]);export{g as __pageData,T as default};
